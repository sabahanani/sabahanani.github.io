[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "sabahanani.github.io",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "CV.html",
    "href": "CV.html",
    "title": "CV",
    "section": "",
    "text": "CV"
  },
  {
    "objectID": "TidyTuesday1.html",
    "href": "TidyTuesday1.html",
    "title": "Lisa’s Vegetable Garden",
    "section": "",
    "text": "The Tidytuesday challenge published on Monday 20/05/2024 had data on Lisa Lendway’s vegetable garden.\nThere were 6 data sets in total:\nplanting_2020, planting_2021\nharvest_2020, harvest_2021\nspending_2020, spending_2021"
  },
  {
    "objectID": "TidyTuesday1.html#tidytuesday",
    "href": "TidyTuesday1.html#tidytuesday",
    "title": "Lisa’s Vegetable Garden",
    "section": "",
    "text": "The Tidytuesday challenge published on Monday 20/05/2024 had data on Lisa Lendway’s vegetable garden.\nThere were 6 data sets in total:\nplanting_2020, planting_2021\nharvest_2020, harvest_2021\nspending_2020, spending_2021"
  },
  {
    "objectID": "TidyTuesday1.html#the-data-sets",
    "href": "TidyTuesday1.html#the-data-sets",
    "title": "Lisa’s Vegetable Garden",
    "section": "The Data Sets",
    "text": "The Data Sets\nplanting_2020 & planting_2021:\nThese data sets contained the following variables: vegetable, variation, number of seeds planted, and date.\nharvest_2020 & harvest_2021:\nThese data sets contained the following variables: vegetable, variation, date, weight, and units.\nspending_2020 & spending_2021:\nThese data sets contained the following variables: vegetable, variation, brand, and price (with and without tax)."
  },
  {
    "objectID": "TidyTuesday1.html#the-research-question",
    "href": "TidyTuesday1.html#the-research-question",
    "title": "Lisa’s Vegetable Garden",
    "section": "The Research Question",
    "text": "The Research Question\nMy exploration question was: what are the vegetables that yield the highest weight (in grams) per seed planted?\nIn other words, how many grams does each seed yield for each vegetable?"
  },
  {
    "objectID": "TidyTuesday1.html#how-was-the-data-explored",
    "href": "TidyTuesday1.html#how-was-the-data-explored",
    "title": "Lisa’s Vegetable Garden",
    "section": "How was the Data Explored?",
    "text": "How was the Data Explored?\nAfter I downloaded the data sets from the official tidytuesday github repository, I merged them by common columns (year, variation, vegetable).\nAfter that, I calculated grams per seed by summing weight and seed count separately, and I divided the overall weight by seed count (grouped by vegetable).\ngrams per seed = overall vegetable weight/overall number of seeds planted\nI decided to visualize the top 3 vegetables that yielded the most weight per seed."
  },
  {
    "objectID": "TidyTuesday1.html#the-code",
    "href": "TidyTuesday1.html#the-code",
    "title": "Lisa’s Vegetable Garden",
    "section": "The Code",
    "text": "The Code\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggimage)\nlibrary(grid)\nlibrary(png)\n#loading the data\nspending_data &lt;- read.csv(\"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/spending_data.csv\")\nplanted_vegetables &lt;- read.csv(\"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/planted_vegetables.csv\")\nharvested_vegetables &lt;- read.csv(\"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/harvested_vegetables.csv\")\n#merging the data\nmerged_data &lt;- merge(planted_vegetables, harvested_vegetables, by = c(\"year\", \"vegetable\", \"variety\"), all = TRUE)\nmerged_data &lt;- merge(merged_data, spending_data, by = c(\"year\", \"vegetable\", \"variety\"), all = TRUE)\nmerged_data &lt;- select(merged_data, -date.x, -date.y, -notes, -eggplant_item_number, -plot,-brand,-variety,-year,-price)\nmerged_data&lt;-na.omit(merged_data)\nsetwd(\"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday\")\nwrite.csv(merged_data,\"merged_data.csv\", row.names = FALSE)\n#converting the relevant variables to numeric (making sure)\nmerged_data &lt;- merged_data |&gt; \n  mutate(\n    number_seeds_planted = as.numeric(number_seeds_planted),\n    weight = as.numeric(weight),\n    price_with_tax = as.numeric(price_with_tax)  # Ensure this column is numeric too\n  )\n#calculating grams per seed\ngrouped_data &lt;- merged_data |&gt; \n  group_by(vegetable) |&gt; \n  summarise(\n    total_weight = sum(weight),\n    total_seeds = sum(number_seeds_planted),\n    .groups = \"drop\"  \n  ) |&gt; \n  mutate(\n    grams_per_seed = total_weight / total_seeds,\n  )\n#top 3 vegetables by grams_per_seed\ntop_vegetables &lt;- grouped_data |&gt; arrange(desc(grams_per_seed)) |&gt; head(3) |&gt; arrange(grams_per_seed)\n#arranging\nvegetable_order &lt;- top_vegetables$vegetable\ntop_vegetables &lt;- top_vegetables |&gt; mutate(vegetable = factor(vegetable, levels = vegetable_order))\n#images to replace bars, and adding images as labels\npics&lt;-c(\"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/finalimages/IMG_5578-removebg-preview.png\",\n        \"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/finalimages/Screenshot_2024-05-31_at_13.20.05-removebg-preview.png\",\n        \"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/finalimages/Screenshot_2024-05-31_at_13.20.26-removebg-preview.png\"\n        )\nlabelpics&lt;-c(\"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/finalimages/407-removebg-preview (1).png\",\n             \"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/finalimages/576-removebg-preview.png\",\n             \"/Users/sabahanani/Desktop/תואר שני/Semester B/מעבדה במדעי הנתונים ופסיכולוגיה/tidytuesday/finalimages/618-removebg-preview.png\")\n#image sizing\nimage_rasters &lt;- lapply(pics, function(path) rasterGrob(readPNG(path), interpolate = TRUE))\n#plotting\np &lt;- ggplot(top_vegetables, aes(x = vegetable, y = grams_per_seed)) +\n  geom_bar(stat = \"identity\", fill = \"transparent\") +\n  scale_y_continuous(limits = c(0, 800), breaks = seq(0, 800, by = 50)) +\n  labs(title = \"Top Crops by Average Crop Yield\", \n       subtitle = \"(Grams harvested per seed)\",\n       x = \"Crop\", y = \"Crop Yield (in grams)\") +\n  theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = \"turquoise4\"),\n    plot.background = element_rect(fill = \"turquoise4\"),\n    plot.title = element_text(color = \"white\", hjust = 0.5),\n    plot.subtitle = element_text(color = \"white\", hjust = 0.5),\n    axis.text = element_text(color = \"white\"),\n    axis.title = element_text(color = \"white\"),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank()\n  ) + \n  geom_image(aes(image = labelpics), size = 0.3, by = \"width\") \n#adding custom annotations for each image, adjusting on y-axis\nfor (i in seq_along(image_rasters)) {\n  p &lt;- p + annotation_custom(\n    grob = image_rasters[[i]], \n    xmin = i - 0.4, xmax = i + 0.4,\n    ymin = -50, ymax = top_vegetables$grams_per_seed[i]+12\n  )\n}\n#viewing the plot\np &lt;- p + labs(\n  caption = paste(\"Source: Lisa's Vegetable Garden, tidytuesday repo\", \"\\nAI art generated by Microsoft's Copilot\", sep = \"\"),\n  x = \"Crop\", y = \"Crop Yield (in grams)\"\n) +\n  theme(\n    plot.caption = element_text(color = \"white\")  \n  )\n# Viewing the plot\np"
  },
  {
    "objectID": "TidyTuesday1.html#results",
    "href": "TidyTuesday1.html#results",
    "title": "Lisa’s Vegetable Garden",
    "section": "Results",
    "text": "Results\nThe three top vegetables were zucchini, tomatoes, and pumpkins. Pumpkins yielded about 618 grams per seed, tomatoes yielded about 576 grams per seed, and zucchinis yielded about 407 grams per seed.\nHowever, there are factors that were not taken into account.\n\nFactors that Could Influence the Data\nEnvironmental factors: soil quality, temperature, moisture, and sun exposure.\nVegetable variation: the exploration question did not take the vegetable variation into account."
  },
  {
    "objectID": "Projects.html",
    "href": "Projects.html",
    "title": "Projects",
    "section": "",
    "text": "Tidytuesday of May 20, 2024\n\n\n\n\n\n\n\nSQL Class Assignment\n\n\n\n\n\n\n\nInteractive PowerBI Dashboard"
  },
  {
    "objectID": "Assignment_Saba.html",
    "href": "Assignment_Saba.html",
    "title": "SQL Class Assignment",
    "section": "",
    "text": "You are a data scientist at Strauss-Elite.\nYour boss hands you a data request by a client. You said you would get to it the next day - but that night you went out partying, and when you awoke the next morning you found the following query typed out on your computer, having no recollection of writing it, nor can you find the client’s request.\nWITH total_orders AS (\nSELECT cid, SUM(Price * amount) AS sum_total\nFROM `orders`\nLEFT JOIN products USING (pid)\nWHERE (sale_date &gt; '2023-01-01')\nGROUP BY cid\n)\nSELECT *\nFROM total_orders\nLEFT JOIN customers USING (cid)\nORDER BY sum_total DESC\nLIMIT 1\n\n1. Assuming you got it right - what did the client want? Explain the query.\nTo understand the query, we must break it down by working inside out, then explain it line by line (or clause by clause).\nThe query starts with WITH, which is a Common Table Expression. What WITH does is make nested queries more readable. It gives temporary names to each query instead of nesting the queries together in a complex way. This makes the code more manageable.\n\nLet’s break down the first sub-query:\nIn the first line, a certain query is named “total_orders.”\nLEFT JOIN products USING (pid) WHERE (sale_date &gt; '2023-01-01')\nFirst of all, before we explain the SELECT statement, we have to understand where we are extracting, or SELECTing, from.\nWe are left joining the orders table with another table called products. What LEFT JOIN does is join all the relevant rows from the left table (in this case orders), with another table using certain criteria. Here, we are using the column pid (product id) to join the two tables. The join will be done using rows from the orders table in the pid column, which have matching values in the pid column in the products table.\nHowever, this join is filtered with WHERE. We are left joining the two tables on the condition that the sale_date (the date where the sale was made) column in the orders table has values bigger than 2023-01-01.\nSo, we are left joining the matching rows in the orders table with the products table based on the pid column, focusing on rows that have values more than 2023-01-01.\n\nSELECT cid, SUM(Price * amount) AS sum_total\nIn this line, we are selecting the column cid (customer id, found in the orders table). We are also selecting the columns Price (price of the candy bar, from the products table) and amount (amount of candy bars purchased, from the orders table), multiplying them (each row with the corresponding row), then summing the multiplication product for the corresponding cid. This sum of multiplications is named sum_total.\nThese columns are extracted from the joining of the two tables.\nAnd as a whole:\n\nWITH total_orders AS ( SELECT cid, SUM(Price * amount) AS sum_total FROM orders LEFT JOIN products USING (pid) WHERE (sale_date &gt; '2023-01-01') GROUP BY cid )\n\nThis sub-query, previously named total_orders with the WITH statement, left joins the tables orders and products based on the pid column. For each cid (GROUP BY cid), a sum_total is calculated, and the results that are shown are those after the date of January 1st, 2023.\n\nNow, let’s break down the second sub-query:\n\nLEFT JOIN customers USING (cid)\nAs said before, before we understand the SELECT statement, we have to know where we are selecting from. Here, we are left joining total_orders with a new table called customers, based on matching rows in the cid column.\nSELECT * FROM total_orders\nNow, we are selecting all columns from the joining of these two tables.\nORDER BY sum_total DESC\nThis line orders the results by the sum_total column in descending order. The highest values will be shown first.\nLIMIT 1\nHere, we are limiting the rows to one. This means that only one row will be shown. Since the results are shown in descending order based on the sum_total column, this means that the highest value will be shown.\nAnd, as a whole, again:\nSELECT * FROM total_orders LEFT JOIN customers USING (cid) ORDER BY sum_total DESC LIMIT 1\nThis sub-query, in summary, left joins the total_orders table with the customers table using the cid column. It orders the table based on the sum_total column in descending order, and only the row with the highest sum_total value will be extracted.\nTaking these explanations into account, now we can sum up the whole query:\nIn the first sub-query, we are left joining the orders table with the products table. Then we calculate, for each customer, the amount of money (sum_total) they spent on candy bars by multiplying the price of the candy bar by the amount purchased. This is only done for orders that were made after January 1st, 2023. This whole extraction is now called total_orders.\nIn the second sub-query, we are left joining the total_orders table with the customers table, orders the results in descending order based on how much money was spent, and shows the customer with the highest sum_total value.\nTherefore, we can say that, essentially, this query extracts the customer id (cid) that spent the most amount of money (sum_total) on candy bars after January 1st, 2023.\n\n2. Run the query - what is the answer?\n\nTo run the query, we must first set up a fake database connection.\n\nlibrary(DBI)\nlibrary(RSQLite)\ncon_chocolate &lt;- dbConnect(drv = SQLite(),\ndbname = \"/Users/sabahanani/Desktop/Projects/sabahanani.github.io/chocolate.sqlite\")\n\nNow, we can run the query.\n\nWITH total_orders AS (\nSELECT cid, SUM(Price * amount) AS sum_total\nFROM `orders`\nLEFT JOIN products USING (pid)\nWHERE (sale_date &gt; '2023-01-01')\nGROUP BY cid\n)\nSELECT *\nFROM total_orders\nLEFT JOIN customers USING (cid)\nORDER BY sum_total DESC\nLIMIT 1\n\n\n1 records\n\n\ncid\nsum_total\nName\nAddress\n\n\n\n\n822\n1057.03\nBeieler, Joshua\n1866 Smith St., Jacobson, Michigan\n\n\n\n\n\nAs we can see, the output of the query is the customer who spent the most on candy bars: his id (822), the sum he spent (1057.03), his name (Joshua Beieler), and his address (1866 Smith St., Jacobson, Michigan)."
  },
  {
    "objectID": "Assignment_Saba.html#q1",
    "href": "Assignment_Saba.html#q1",
    "title": "SQL Class Assignment",
    "section": "",
    "text": "You are a data scientist at Strauss-Elite.\nYour boss hands you a data request by a client. You said you would get to it the next day - but that night you went out partying, and when you awoke the next morning you found the following query typed out on your computer, having no recollection of writing it, nor can you find the client’s request.\nWITH total_orders AS (\nSELECT cid, SUM(Price * amount) AS sum_total\nFROM `orders`\nLEFT JOIN products USING (pid)\nWHERE (sale_date &gt; '2023-01-01')\nGROUP BY cid\n)\nSELECT *\nFROM total_orders\nLEFT JOIN customers USING (cid)\nORDER BY sum_total DESC\nLIMIT 1\n\n1. Assuming you got it right - what did the client want? Explain the query.\nTo understand the query, we must break it down by working inside out, then explain it line by line (or clause by clause).\nThe query starts with WITH, which is a Common Table Expression. What WITH does is make nested queries more readable. It gives temporary names to each query instead of nesting the queries together in a complex way. This makes the code more manageable.\n\nLet’s break down the first sub-query:\nIn the first line, a certain query is named “total_orders.”\nLEFT JOIN products USING (pid) WHERE (sale_date &gt; '2023-01-01')\nFirst of all, before we explain the SELECT statement, we have to understand where we are extracting, or SELECTing, from.\nWe are left joining the orders table with another table called products. What LEFT JOIN does is join all the relevant rows from the left table (in this case orders), with another table using certain criteria. Here, we are using the column pid (product id) to join the two tables. The join will be done using rows from the orders table in the pid column, which have matching values in the pid column in the products table.\nHowever, this join is filtered with WHERE. We are left joining the two tables on the condition that the sale_date (the date where the sale was made) column in the orders table has values bigger than 2023-01-01.\nSo, we are left joining the matching rows in the orders table with the products table based on the pid column, focusing on rows that have values more than 2023-01-01.\n\nSELECT cid, SUM(Price * amount) AS sum_total\nIn this line, we are selecting the column cid (customer id, found in the orders table). We are also selecting the columns Price (price of the candy bar, from the products table) and amount (amount of candy bars purchased, from the orders table), multiplying them (each row with the corresponding row), then summing the multiplication product for the corresponding cid. This sum of multiplications is named sum_total.\nThese columns are extracted from the joining of the two tables.\nAnd as a whole:\n\nWITH total_orders AS ( SELECT cid, SUM(Price * amount) AS sum_total FROM orders LEFT JOIN products USING (pid) WHERE (sale_date &gt; '2023-01-01') GROUP BY cid )\n\nThis sub-query, previously named total_orders with the WITH statement, left joins the tables orders and products based on the pid column. For each cid (GROUP BY cid), a sum_total is calculated, and the results that are shown are those after the date of January 1st, 2023.\n\nNow, let’s break down the second sub-query:\n\nLEFT JOIN customers USING (cid)\nAs said before, before we understand the SELECT statement, we have to know where we are selecting from. Here, we are left joining total_orders with a new table called customers, based on matching rows in the cid column.\nSELECT * FROM total_orders\nNow, we are selecting all columns from the joining of these two tables.\nORDER BY sum_total DESC\nThis line orders the results by the sum_total column in descending order. The highest values will be shown first.\nLIMIT 1\nHere, we are limiting the rows to one. This means that only one row will be shown. Since the results are shown in descending order based on the sum_total column, this means that the highest value will be shown.\nAnd, as a whole, again:\nSELECT * FROM total_orders LEFT JOIN customers USING (cid) ORDER BY sum_total DESC LIMIT 1\nThis sub-query, in summary, left joins the total_orders table with the customers table using the cid column. It orders the table based on the sum_total column in descending order, and only the row with the highest sum_total value will be extracted.\nTaking these explanations into account, now we can sum up the whole query:\nIn the first sub-query, we are left joining the orders table with the products table. Then we calculate, for each customer, the amount of money (sum_total) they spent on candy bars by multiplying the price of the candy bar by the amount purchased. This is only done for orders that were made after January 1st, 2023. This whole extraction is now called total_orders.\nIn the second sub-query, we are left joining the total_orders table with the customers table, orders the results in descending order based on how much money was spent, and shows the customer with the highest sum_total value.\nTherefore, we can say that, essentially, this query extracts the customer id (cid) that spent the most amount of money (sum_total) on candy bars after January 1st, 2023.\n\n2. Run the query - what is the answer?\n\nTo run the query, we must first set up a fake database connection.\n\nlibrary(DBI)\nlibrary(RSQLite)\ncon_chocolate &lt;- dbConnect(drv = SQLite(),\ndbname = \"/Users/sabahanani/Desktop/Projects/sabahanani.github.io/chocolate.sqlite\")\n\nNow, we can run the query.\n\nWITH total_orders AS (\nSELECT cid, SUM(Price * amount) AS sum_total\nFROM `orders`\nLEFT JOIN products USING (pid)\nWHERE (sale_date &gt; '2023-01-01')\nGROUP BY cid\n)\nSELECT *\nFROM total_orders\nLEFT JOIN customers USING (cid)\nORDER BY sum_total DESC\nLIMIT 1\n\n\n1 records\n\n\ncid\nsum_total\nName\nAddress\n\n\n\n\n822\n1057.03\nBeieler, Joshua\n1866 Smith St., Jacobson, Michigan\n\n\n\n\n\nAs we can see, the output of the query is the customer who spent the most on candy bars: his id (822), the sum he spent (1057.03), his name (Joshua Beieler), and his address (1866 Smith St., Jacobson, Michigan)."
  },
  {
    "objectID": "Assignment_Saba.html#q2",
    "href": "Assignment_Saba.html#q2",
    "title": "SQL Class Assignment",
    "section": "Q2",
    "text": "Q2\nIn a single query, find:\n• Who is the sales rep that made the larger number of sales compared to the average of all sales reps that were recruited in the same year as him? How many sales?\n• Who is their top customer (with the largest purchase)?\n• What is the sales rep most sold candy bar?\n\n(Supply both the answer and the query.)\nFirst of all, let’s write a sub-query to find the average sales of each sales rep compared to the average sales of the sales reps recruited in the same year:\n\nSELECT srid, Name, year_joined, COUNT(amount) AS sales_count, AVG(COUNT(amount)) OVER (PARTITION BY year_joined) AS avg_sales\nFROM salesreps LEFT JOIN orders USING(srid)\nGROUP BY srid\n\n\nDisplaying records 1 - 10\n\n\nsrid\nName\nyear_joined\nsales_count\navg_sales\n\n\n\n\n8\nChen, Alexander\n2008\n148\n155.3333\n\n\n15\nValdez, Nohemi\n2008\n148\n155.3333\n\n\n23\nSchwarzenbach, Joshua\n2008\n170\n155.3333\n\n\n9\nAragon, Ashley\n2009\n171\n166.5000\n\n\n10\nGraves, Blanca\n2009\n162\n166.5000\n\n\n14\nTootle, Naudia\n2010\n170\n166.0000\n\n\n26\nal-Sadri, Saamyya\n2010\n150\n166.0000\n\n\n27\nal-Farrah, Ghaaliba\n2010\n178\n166.0000\n\n\n13\nRegister, Tayanna\n2011\n176\n168.6667\n\n\n20\nKim, Miles\n2011\n164\n168.6667\n\n\n\n\n\nLet’s break down the sub-query line by line:\nFROM salesreps LEFT JOIN orders USING(srid)\n\nIn this line, we are left joining the salesreps table with the orders table, based on the srid column.\n\nSELECT srid, Name, year_joined,COUNT(amount) AS sales_count, AVG(COUNT(amount)) OVER (PARTITION BY year_joined) AS avg_sales\n\nHere, we are selecting the srid, Name, and year_joned columns from the joining of the two tables. In addition, we are extracting the sales count of each sales rep, by using COUNT(amount) (this is given an alias of sales_count). To calculate the average of each sales count in a certain year, AVG(COUNT(amount)) is used, and PARTITIONed over year_joined (later given an alias of avg_sales).\n\nGROUP BY srid\nThe results are then grouped by the sales rep’s id.\n\nNow, let’s find the sales rep with the largest amount of sales compared to the sales reps who were recruited in the same year as them.\nBut first, let’s give the initial sub-query an alias so we can reuse it:\n\nWITH sales_year_avg AS (\n    SELECT srid, Name, year_joined,COUNT(amount) AS sales_count, AVG(COUNT(amount)) OVER (PARTITION BY year_joined) AS avg_sales\n    FROM salesreps LEFT JOIN orders USING(srid)\n    GROUP BY srid\n)\n--now let's select the salesrep with the most sales compared to the avg:\nSELECT *\nFROM sales_year_avg\nWHERE sales_count &gt; avg_sales\nORDER BY (sales_count - avg_sales) DESC\nLIMIT 1\n\n\n1 records\n\n\nsrid\nName\nyear_joined\nsales_count\navg_sales\n\n\n\n\n7\nPryor, Briana\n2018\n177\n159\n\n\n\n\n\nFROM sales_year_avg\n\nWe are extracting from the initial sub-query, now named sales_year_avg. Previously, that sub-query calculated the average of the sales amount, partitioned by year.\n\nSELECT *\n\nNow, we are selecting, from sales_year_avg, all columns.\n\nWHERE sales_count &gt; avg_sales\n\nwe are filtering the rows selected, where the rows that will be extracted are the rows were the sales_count is larger than the avg_sales.\n\nORDER BY (sales_count - avg_sales) DESC LIMIT 1\n\nNow, we are ordering the filtered rows based on the difference between sales_count and avg_sales in descending order. Then, we are limiting the results to one row. Since the rows are in a descending order, this should give us the sales rep with the largest difference between sales_amount and avg_sales.\n\nNow, let’s find the sale’s rep’s top customer (with the largest purchase-according to how many candy bars purchased and not how much they paid):\n\n\nSELECT customers.cid, Name AS customer_name, SUM(amount) AS total_purchase, orders.srid\nFROM customers \nINNER JOIN orders ON customers.cid = orders.cid\nGROUP BY orders.cid\nORDER BY total_purchase DESC\n\n\nDisplaying records 1 - 10\n\n\ncid\ncustomer_name\ntotal_purchase\nsrid\n\n\n\n\n113\nGarcia, Christina\n194\n2\n\n\n275\nLavaka, Ashleigh\n179\n7\n\n\n118\nGreene, Grigoriy\n177\n4\n\n\n129\nDemby, Kyle\n174\n1\n\n\n379\nal-Hashmi, Inaaya\n171\n4\n\n\n50\nBrooks, Cody\n170\n2\n\n\n675\nMack, Magdalena\n169\n6\n\n\n591\nal-Abdul, Zaghlool\n169\n4\n\n\n767\nal-Habibi, Hamdoona\n166\n4\n\n\n753\nel-Muhammed, Marwa\n165\n2\n\n\n\n\n\nFROM customers  INNER JOIN orders ON customers.cid = orders.cid\n\nHere, we are joining the customers table with the orders table using the cid column. The join of these tables will be our new table.\n\nSELECT Name AS customer_name, SUM(amount) AS total_purchase, srid\n\nNow, we are selecting the name of the customer (customer_name), the sum of the amount of candy bars they purchased (SUM(amount)-total_purchase). I gave the customer’s name an alias because I don’t want it to get confused with the sales reps names. Selecting srid will help us find the sales rep later.\nGROUP BY orders.cid To find the amount purchased by each customer, they have to be grouped by customer id.\n\nORDER BY total_purchase\n\nThen, total_purchase is ordered in a descending manner, where the customer with the biggest purchase will be on top.\n\nNow, let’s join them:\n\n\nWITH sales_year_avg AS (\n    SELECT srid, Name, year_joined,COUNT(amount) AS sales_count, AVG(COUNT(amount)) OVER (PARTITION BY year_joined) AS avg_sales\n    FROM salesreps LEFT JOIN orders USING(srid)\n    GROUP BY srid),\n--giving an alias to the top sales rep\ntop_salesrep AS (\n SELECT *\n FROM sales_year_avg\n WHERE sales_count &gt; avg_sales\n ORDER BY (sales_count - avg_sales) DESC\n LIMIT 1\n ),\n--giving an alias to the top customer\ntop_customer AS (\n SELECT Name AS customer_name, SUM(amount) AS total_purchase, orders.srid\n FROM customers \n INNER JOIN orders ON customers.cid = orders.cid\n GROUP BY orders.cid\n ORDER BY total_purchase DESC\n)\n--finding the top customer for the top sales rep\nSELECT *\nFROM top_salesrep INNER JOIN top_customer \nUSING(srid)\nLIMIT 1\n\n\n1 records\n\n\n\n\n\n\n\n\n\n\n\nsrid\nName\nyear_joined\nsales_count\navg_sales\ncustomer_name\ntotal_purchase\n\n\n\n\n7\nPryor, Briana\n2018\n177\n159\nLavaka, Ashleigh\n179\n\n\n\n\n\nTo find the sales rep most sold candy bar:\n\nSELECT candy_names, SUM(amount), orders.srid\nFROM orders INNER JOIN products \nON orders.pid=products.pid\nGROUP BY candy_names\nORDER BY SUM(amount) DESC\n\n\nDisplaying records 1 - 10\n\n\ncandy_names\nSUM(amount)\nsrid\n\n\n\n\nMarshmallow Dream\n4127\n19\n\n\nCoconut Crave\n4126\n6\n\n\nLemon Zest\n3992\n25\n\n\nBlueberry Blast\n3988\n30\n\n\nFudge Fusion\n3936\n28\n\n\nStrawberry Swirl\n3865\n28\n\n\nToffee Temptation\n3842\n20\n\n\nAlmond Bliss\n3839\n22\n\n\nChoco Blast\n3771\n2\n\n\nCaramel Crunch\n3737\n1\n\n\n\n\n\nFROM orders INNER JOIN products  ON orders.pid=products.pid\n\nFirst, we join the order table with the products table using pid.\n\nSELECT candy_names, SUM(amount), orders.srid\n\nThen, we select the candy_names, how many of each was purchased, and the sales rep id (srid). This will help us find the sales rep later.\n\nGROUP BY candy_names ORDER BY SUM(amount) DESC\n\nLater, we group by candy names because we’re interested in it as a whole category. Then, we order the results in a descending manner so the candy name with the most amount purchased will be shown first.\n\nNow, let’s find the sale’s rep most sold candy bar name by joining:\n\n\nWITH sales_year_avg AS (\n    SELECT srid, Name, year_joined,COUNT(amount) AS sales_count, AVG(COUNT(amount)) OVER (PARTITION BY year_joined) AS avg_sales\n    FROM salesreps LEFT JOIN orders USING(srid)\n    GROUP BY srid),\n--giving an alias to the top sales rep\ntop_salesrep AS (\n SELECT *\n FROM sales_year_avg\n WHERE sales_count &gt; avg_sales\n ORDER BY (sales_count - avg_sales) DESC\n LIMIT 1\n ),\n--giving an alias to the top customer\ntop_customer AS (\n SELECT Name AS customer_name, SUM(amount) AS total_purchase, orders.srid\n FROM customers \n INNER JOIN orders ON customers.cid = orders.cid\n GROUP BY orders.cid\n ORDER BY total_purchase DESC\n),\n--finding the top customer for the top sales rep, giving it an alias:\ntop_sales_customer AS (\n SELECT *\n FROM top_salesrep INNER JOIN top_customer \n USING(srid)\n LIMIT 1\n ),\n--giving an alias to the most sold candy:\ntop_candy AS (\n SELECT candy_names, SUM(amount), orders.srid\n FROM orders INNER JOIN products \n ON orders.pid=products.pid\n GROUP BY candy_names\n ORDER BY SUM(amount) DESC\n)\n--finding the sales rep most sold candy:\nSELECT *\nFROM top_sales_customer INNER JOIN top_candy \nUSING(srid)\nLIMIT 1\n\n\n1 records\n\n\n\n\n\n\n\n\n\n\n\n\n\nsrid\nName\nyear_joined\nsales_count\navg_sales\ncustomer_name\ntotal_purchase\ncandy_names\nSUM(amount)\n\n\n\n\n7\nPryor, Briana\n2018\n177\n159\nLavaka, Ashleigh\n179\nCookies ’n Cream\n3672\n\n\n\n\n\nTo sum up, the best performing sales representative compared to the average of the sales made by others recruited in the same year is: Briana Pryor, with a sales count of 177.\nTheir top customer is: Ashleigh Lavaka (found according to how many candy bars she purchased).\nTheir most sold candy bar is: Cookies ’n Cream"
  }
]